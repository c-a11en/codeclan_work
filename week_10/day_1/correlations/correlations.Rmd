---
title: "R Notebook"
output: html_notebook
---

```{r}

library(tidyverse)
library(janitor)

```


```{r}

mtcars %>% 
  select(wt, mpg) %>% 
  glimpse()

```

```{r}

mtcars %>% 
  ggplot(aes(x = wt, y = mpg)) +
  geom_point()

```

```{r}

mtcars %>% 
  ggplot(aes(x = wt, y = mpg)) +
  geom_point() +
  # add centroid to plot, i.e. (x, y) = (mean(x), mean(y))
  geom_point(aes(x = mean(wt), y = mean(mpg)), col = "red", size = 3)

```

# Pearson correlation coefficient



```{r}

noisy_bivariate <- function(noise = 1, gradient = 1){
  x <- runif(n = 200, min = 0, max = 10)
  y <- gradient * x + 10
  y_scatter <- noise * 4 * rnorm(n = 200)
  y <- y + y_scatter
  data = tibble(x, y)

  r <- round(cor(x, y), 4)
  title <- paste(
    "noise = ", noise,
    ", gradient = ", gradient,
    ", r = ", r
  )
  
  data %>%
    ggplot(aes(x = x, y = y)) +
    geom_point() +
    xlim(0, 10) +
    ylim(min(c(min(y), 0)), max(c(max(y), 10))) +
    ggtitle(title)
  
}
noisy_bivariate(noise = 1, gradient = -1)

```

```{r}

mtcars %>% 
  summarise(cor(mpg, wt))

```


```{r}

mtcars %>% 
  summarise(cor(wt, mpg))

# no change when order of x and y are switched

```

```{r}
# Pivot longer:
anscombe_long <- anscombe %>%
pivot_longer(everything(),
names_to = c(".value", "set"),
names_pattern = c("(\\D+)(\\d+)"))

# Group by set and get the correlation coefficient for each:
anscombe_long %>%
group_by(set) %>%
summarise(r = cor(x, y))

# Plot the quartet:
anscombe_long %>%
ggplot() +
aes(x = x, y = y) +
geom_point() +
facet_wrap(~set)

```

# Task - 10 minutes
Now calculate the four correlation coefficients between the data pairs plotted above (x1 with y1 and so on). The data can be found in the built-in anscombe dataset.
What do you notice about the correlation coefficients?
Looking at each plot, think about whether the resulting coefficient accurately represents the pattern in the data.

```{r}

anscombe_long %>% 
  group_by(set) %>% 
  summarise(r = cor(x, y))

```

The correlation coefficients are very similar between each data set. However, the plot themselves are very different therefore the r-value is not useful in all scenarios, i.e. not useful for set 2 or 4.


# Task - 15 mins
Letâ€™s calculate correlation coefficients for various variables in the state.x77 dataset!


```{r}

summary(state.x77)

tibble_states <- clean_names(as_tibble(state.x77))

tibble_states

```


```{r}
# population vs life_exp
tibble_states %>% 
  ggplot(aes(x = population, y = life_exp)) +
  geom_point()

tibble_states %>% 
  summarise(r = cor(population, life_exp))

```


```{r}
# illiteracy vs hs grad

tibble_states %>% 
  ggplot(aes(x = illiteracy, y = hs_grad)) +
  geom_point()

tibble_states %>% 
  summarise(r = cor(illiteracy, hs_grad))

```

```{r}
# murder and illiteracy

tibble_states %>% 
  ggplot(aes(x = illiteracy, y = murder)) +
  geom_point()

tibble_states %>% 
  summarise(r = cor(illiteracy, murder))

```

```{r}
# income and life expectancy

tibble_states %>% 
  ggplot(aes(x = income, y = life_exp)) +
  geom_point()

tibble_states %>% 
  summarise(r = cor(income, life_exp))

```

```{r}

# population vs murder

tibble_states %>% 
  ggplot(aes(x = population, y = murder)) +
  geom_point()

tibble_states %>% 
  summarise(r = cor(population, murder))

```

```{r}

# hs_grad vs murder

tibble_states %>% 
  ggplot(aes(x = hs_grad, y = murder)) +
  geom_point()

tibble_states %>% 
  summarise(r = cor(hs_grad, murder))


```

```{r}

line <- function(x, a, b) {
  return(a*x + b)
}

data <- tibble(
  x = seq(-5, 5, 0.1),
  y = line(x, a = 2, b = -1)
)

data %>% 
  ggplot(aes(x, y)) +
  geom_line(col = "firebrick") +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0)

```

# Task - 5 mins
Play around plotting two or three different lines.
Try a line with a=0
a=0 and positive b.
You can use mutate() to overwrite y in data from above
Can we use our line() function to plot a perfectly vertical line?

```{r}

data <- data %>% 
  mutate(y = line(x, a = 1, b = -1))

data %>% 
  ggplot(aes(x, y)) +
  geom_line(col = "firebrick") +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = 2, col = "green")

```

```{r}

noisy_line <- read_csv("data/noisy_line.csv")

noisy_line_plot <- noisy_line %>%
  ggplot(aes(x, y)) +
  geom_point()

noisy_line_plot

```

```{r}

centroid <- noisy_line %>%
  summarise(x = mean(x),
            y = mean(y))

centroid

```

```{r}

noisy_line_plot <- noisy_line_plot +
  geom_point(aes(x = centroid$x, y = centroid$y),
             col = "red", size = 3)

noisy_line_plot

```

```{r}

get_intercept <- function(slope, centroid_x, centroid_y) {
  return(centroid_y - slope * centroid_x)
}

```

```{r}

slope <- 0.5

noisy_line_plot +
  geom_abline(slope = slope,
              intercept = get_intercept(slope, centroid$x, centroid$y))

```

# Task - 5 mins
Play around with the code chunk above and try to find a slope that fits the data reasonably well.

```{r}

slope <- 2.1

noisy_line_plot +
  geom_abline(slope = slope,
              intercept = get_intercept(slope, centroid$x, centroid$y))

```

```{r}

noisy_line_plot +
  geom_smooth(method = "lm", se = FALSE)

```

